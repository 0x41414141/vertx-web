= Vert.x-Web OpenAPI 3 support
:toc: left

== OpenAPI 3
You can create your web service based on OpenAPI3 specification with `link:../..

/apidocs/io/vertx/ext/web/designdriven/OpenAPI3RouterFactory.html[OpenAPI3RouterFactory]`. This class, as name says, is a router factory based on your OpenAPI 3 specification. It enables you to add handlers for specific paths (or operationId), and the factory will care to load the correct security and validation handlers.
[source,groovy]
----
// Load the api spec. This operation is asynchronous
OpenAPI3RouterFactory.createRouterFactoryFromFile(vertx, "src/main/resources/petstore.yaml", { openAPI3RouterFactoryAsyncResult ->
  if (openAPI3RouterFactoryAsyncResult.succeeded()) {
    // Spec loaded with success
    def routerFactory = openAPI3RouterFactoryAsyncResult.result()
    // Add an handler with operationId
    routerFactory.addHandlerByOperationId("listPets", { routingContext ->
      // Handle listPets operation
      routingContext.response().setStatusMessage("Called listPets").end()
    }, { routingContext ->
      // This is the failure handler
      def failure = routingContext.failure()
      if (failure instanceof io.vertx.ext.web.validation.ValidationException) {
        routingContext.response().setStatusCode(400).setStatusMessage("ValidationException thrown! ${failure.type().name()}").end()}
    })

    // Add an handler with a combination of HttpMethod and path
    routerFactory.addHandler(HttpMethod.POST, "/pets", { routingContext ->
      // Extract request body and use it
      def params = routingContext.get("parsedParameters")
      def pet = params.body().getJsonObject()
      routingContext.response().putHeader("content-type", "application/json; charset=utf-8").end(groovy.json.JsonOutput.toJson(pet))
    }, { routingContext ->
      def failure = routingContext.failure()
      if (failure instanceof io.vertx.ext.web.validation.ValidationException) {
        routingContext.response().setStatusCode(400).setStatusMessage("ValidationException thrown! ${failure.type().name()}").end()}
    })

    // Add a security handler
    routerFactory.addSecurityHandler("api_key", { routingContext ->
      // Handle security here
      routingContext.next()
    })

    // Before router creation you can enable or disable mounting of a default failure handler for ValidationException
    routerFactory.enableValidationFailureHandler(false)

    // Now you have to generate the router
    def router = routerFactory.getRouter()

    // Now you can use your Router instance
    def server = vertx.createHttpServer([
      port:8080,
      host:"localhost"
    ])
    server.requestHandler(router.&accept).listen()

  } else {
    // Something went wrong during router factory initialization
    def exception = openAPI3RouterFactoryAsyncResult.cause()
  }
})

----
All methods, except `getRouter()` are lazy methods. When you call `getRouter()`, the `Router` will be generated
following the path ordering described in specification.