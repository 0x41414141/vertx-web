= Vert.x-Web OpenAPI 3 support
:toc: left

== OpenAPI 3
You can create your web service based on OpenAPI3 specification with `link:../..

/apidocs/io/vertx/ext/web/designdriven/OpenAPI3RouterFactory.html[OpenAPI3RouterFactory]`. This class, as name says, is a router factory based on your OpenAPI 3 specification. It enables you to add handlers for specific paths (or operationId), and the factory will care to load the correct security and validation handlers.
[source,ruby]
----
require 'json'
require 'vertx-web-contract-openapi/open_api3_router_factory'
# Load the api spec. This operation is asynchronous
VertxWebContractOpenapi::OpenAPI3RouterFactory.create_router_factory_from_file(vertx, "src/main/resources/petstore.yaml") { |openAPI3RouterFactoryAsyncResult_err,openAPI3RouterFactoryAsyncResult|
  if (openAPI3RouterFactoryAsyncResult_err == nil)
    # Spec loaded with success
    routerFactory = openAPI3RouterFactoryAsyncResult
    # Add an handler with operationId
    routerFactory.add_handler_by_operation_id("listPets", lambda { |routingContext|
      # Handle listPets operation
      routingContext.response().set_status_message("Called listPets").end()
    }) { |routingContext|
      # This is the failure handler
      failure = routingContext.failure()
      if (failure.class.name == 'Java::IoVertxExtWebValidation::ValidationException')
        routingContext.response().set_status_code(400).set_status_message("ValidationException thrown! #{failure.type().name()}").end()end
    }

    # Add an handler with a combination of HttpMethod and path
    routerFactory.add_handler(:POST, "/pets", lambda { |routingContext|
      # Extract request body and use it
      params = routingContext.get("parsedParameters")
      pet = params.body().get_json_object()
      routingContext.response().put_header("content-type", "application/json; charset=utf-8").end(JSON.generate(pet))
    }) { |routingContext|
      failure = routingContext.failure()
      if (failure.class.name == 'Java::IoVertxExtWebValidation::ValidationException')
        routingContext.response().set_status_code(400).set_status_message("ValidationException thrown! #{failure.type().name()}").end()end
    }

    # Add a security handler
    routerFactory.add_security_handler("api_key") { |routingContext|
      # Handle security here
      routingContext.next()
    }

    # Before router creation you can enable or disable mounting of a default failure handler for ValidationException
    routerFactory.enable_validation_failure_handler(false)

    # Now you have to generate the router
    router = routerFactory.get_router()

    # Now you can use your Router instance
    server = vertx.create_http_server({
      'port' => 8080,
      'host' => "localhost"
    })
    server.request_handler(&router.method(:accept)).listen()

  else
    # Something went wrong during router factory initialization
    exception = openAPI3RouterFactoryAsyncResult_err
  end
}

----
All methods, except `getRouter()` are lazy methods. When you call `getRouter()`, the `Router` will be generated
following the path ordering described in specification.