= Vert.x-Web API Contract
:toc: left

== Validate the requests
Vert.x provide a validation framework that will validate requests for you and will put results of validation inside a container.

To define a `link:../../apidocs/io/vertx/ext/web/api/validation/HTTPRequestValidationHandler.html[HTTPRequestValidationHandler]`:
[source,java]
----
HTTPRequestValidationHandler validationHandler = HTTPRequestValidationHandler.create().addQueryParam("parameterName", ParameterType.INT, true).addFormParamWithPattern("formParameterName", "a{4}", true).addPathParam("pathParam", ParameterType.FLOAT);
----

Then you can mount your validation handler:
[source,java]
----
router.route().handler(BodyHandler.create());

router.get("/awesome/:pathParam")
  // Mount validation handler
  .handler(validationHandler)
  //Mount your handler
  .handler((routingContext) -> {
    // Get Request parameters container
    RequestParameters params = routingContext.get("parsedParameters");

    // Get parameters
    Integer parameterName = params.queryParameter("parameterName").getInteger();
    String formParameterName = params.formParameter("formParameterName").getString();
    Float pathParam = params.pathParameter("pathParam").getFloat();
  })

  //Mount your failure handler
  .failureHandler((routingContext) -> {
    Throwable failure = routingContext.failure();
    if (failure instanceof ValidationException) {
      // Something went wrong during validation!
      String validationErrorMessage = failure.getMessage();
    }
  });
----

If validation succeeds, It returns request parameters inside `link:../../apidocs/io/vertx/ext/web/api/RequestParameters.html[RequestParameters]`, otherwise It will throw a `link:../../apidocs/io/vertx/ext/web/api/validation/ValidationException.html[ValidationException]`

=== Types of request parameters
Every parameter has a type validator, a class that describes the expected type of parameter.
A type validator validates the value, casts it in required language type and then loads it inside a `link:../../apidocs/io/vertx/ext/web/api/RequestParameter.html[RequestParameter]` object. There are three ways to describe the type of your parameter:

* There is a set of prebuilt types that you can use: `link:../../apidocs/io/vertx/ext/web/api/validation/ParameterType.html[ParameterType]`
* You can instantiate a custom instance of prebuilt type validators using static methods of `link:../../apidocs/io/vertx/ext/web/api/validation/ParameterTypeValidator.html[ParameterTypeValidator]` and then load it into `link:../../apidocs/io/vertx/ext/web/api/validation/HTTPRequestValidationHandler.html[HTTPRequestValidationHandler]` using functions ending with `WithCustomTypeValidator`
* You can create your own `ParameterTypeValidator` implementing `link:../../apidocs/io/vertx/ext/web/api/validation/ParameterTypeValidator.html[ParameterTypeValidator]` interface

=== Handling parameters
Now you can handle parameter values:

[source,java]
----
RequestParameters params = routingContext.get("parsedParameters");
RequestParameter awesomeParameter = params.queryParameter("awesomeParameter");
if (awesomeParameter != null) {
  if (!awesomeParameter.isEmpty()) {
    // Parameter exists and isn't empty
    // ParameterTypeValidator mapped the parameter in equivalent language object
    Integer awesome = awesomeParameter.getInteger();
  } else {
    // Parameter exists, but it's empty
  }
} else {
  // Parameter doesn't exist (it's not required)
}
----

As you can see, every parameter is mapped in respective language objects. You can also get a json body:

[source,java]
----
RequestParameter body = params.body();
if (body != null) {
  JsonObject jsonBody = body.getJsonObject();
}
----