= Vert.x-Web API Contract
:toc: left

== Validate the requests
Vert.x provide a validation framework that will validate requests for you and will put results of validation inside a container.

To define a `link:../../yardoc/VertxWebApiContract/HTTPRequestValidationHandler.html[HTTPRequestValidationHandler]`:
[source,ruby]
----
require 'vertx-web-api-contract/http_request_validation_handler'
# Create Validation Handler with some stuff
validationHandler = VertxWebApiContract::HTTPRequestValidationHandler.create().add_query_param("parameterName", :INT, true).add_form_param_with_pattern("formParameterName", "a{4}", true).add_path_param("pathParam", :FLOAT)

----

Then you can mount your validation handler:
[source,ruby]
----
require 'vertx-web/body_handler'
# BodyHandler is required to manage body parameters like forms or json body
router.route().handler(&VertxWeb::BodyHandler.create().method(:handle))

router.get("/awesome/:pathParam").handler(&validationHandler.method(:handle)).handler() { |routingContext|
  # Get Request parameters container
  params = routingContext.get("parsedParameters")

  # Get parameters
  parameterName = params.query_parameter("parameterName").get_integer()
  formParameterName = params.form_parameter("formParameterName").get_string()
  pathParam = params.path_parameter("pathParam").get_float()
}.failure_handler() { |routingContext|
  failure = routingContext.failure()
  if (failure.class.name == 'Java::IoVertxExtWebApiValidation::ValidationException')
    # Something went wrong during validation!
    validationErrorMessage = failure.get_message()
  end
}

----

If validation succeeds, It returns request parameters inside `link:../../yardoc/VertxWebApiContract/RequestParameters.html[RequestParameters]`, otherwise It will throw a `link:unavailable[ValidationException]`

=== Types of request parameters
Every parameter has a type validator, a class that describes the expected type of parameter.
A type validator validates the value, casts it in required language type and then loads it inside a `link:../../yardoc/VertxWebApiContract/RequestParameter.html[RequestParameter]` object. There are three ways to describe the type of your parameter:

* There is a set of prebuilt types that you can use: `link:../enums.html#ParameterType[ParameterType]`
* You can instantiate a custom instance of prebuilt type validators using static methods of `link:../../yardoc/VertxWebApiContract/ParameterTypeValidator.html[ParameterTypeValidator]` and then load it into `link:../../yardoc/VertxWebApiContract/HTTPRequestValidationHandler.html[HTTPRequestValidationHandler]` using functions ending with `WithCustomTypeValidator`
* You can create your own `ParameterTypeValidator` implementing `link:../../yardoc/VertxWebApiContract/ParameterTypeValidator.html[ParameterTypeValidator]` interface

=== Handling parameters
Now you can handle parameter values:

[source,ruby]
----
params = routingContext.get("parsedParameters")
awesomeParameter = params.query_parameter("awesomeParameter")
if (awesomeParameter != nil)
  if (!awesomeParameter.empty?())
    # Parameter exists and isn't empty
    # ParameterTypeValidator mapped the parameter in equivalent language object
    awesome = awesomeParameter.get_integer()
  else
    # Parameter exists, but it's empty
  end
else
  # Parameter doesn't exist (it's not required)
end

----

As you can see, every parameter is mapped in respective language objects. You can also get a json body:

[source,ruby]
----
body = params.body()
if (body != nil)
  jsonBody = body.get_json_object()
end

----