= Vert.x-Web API Contract
:toc: left

== Validate the requests
Vert.x provide a validation framework that will validate requests for you and will put results of validation inside a container.

To define a `link:../../jsdoc/module-vertx-web-api-contract-js_http_request_validation_handler-HTTPRequestValidationHandler.html[HTTPRequestValidationHandler]`:
[source,js]
----
var HTTPRequestValidationHandler = require("vertx-web-api-contract-js/http_request_validation_handler");
// Create Validation Handler with some stuff
var validationHandler = HTTPRequestValidationHandler.create().addQueryParam("parameterName", 'INT', true).addFormParamWithPattern("formParameterName", "a{4}", true).addPathParam("pathParam", 'FLOAT');

----

Then you can mount your validation handler:
[source,js]
----
var BodyHandler = require("vertx-web-js/body_handler");
// BodyHandler is required to manage body parameters like forms or json body
router.route().handler(BodyHandler.create().handle);

router.get("/awesome/:pathParam").handler(validationHandler.handle).handler(function (routingContext) {
  // Get Request parameters container
  var params = routingContext.get("parsedParameters");

  // Get parameters
  var parameterName = params.queryParameter("parameterName").getInteger();
  var formParameterName = params.formParameter("formParameterName").getString();
  var pathParam = params.pathParameter("pathParam").getFloat();
}).failureHandler(function (routingContext) {
  var failure = routingContext.failure();
  if (failure.getClass().getSimpleName() == 'ValidationException') {
    // Something went wrong during validation!
    var validationErrorMessage = failure.getMessage();
  }
});

----

If validation succeeds, It returns request parameters inside `link:../../jsdoc/module-vertx-web-api-contract-js_request_parameters-RequestParameters.html[RequestParameters]`, otherwise It will throw a `ValidationException`

=== Types of request parameters
Every parameter has a type validator, a class that describes the expected type of parameter.
A type validator validates the value, casts it in required language type and then loads it inside a `link:../../jsdoc/module-vertx-web-api-contract-js_request_parameter-RequestParameter.html[RequestParameter]` object. There are three ways to describe the type of your parameter:

* There is a set of prebuilt types that you can use: `link:../enums.html#ParameterType[ParameterType]`
* You can instantiate a custom instance of prebuilt type validators using static methods of `link:../../jsdoc/module-vertx-web-api-contract-js_parameter_type_validator-ParameterTypeValidator.html[ParameterTypeValidator]` and then load it into `link:../../jsdoc/module-vertx-web-api-contract-js_http_request_validation_handler-HTTPRequestValidationHandler.html[HTTPRequestValidationHandler]` using functions ending with `WithCustomTypeValidator`
* You can create your own `ParameterTypeValidator` implementing `link:../../jsdoc/module-vertx-web-api-contract-js_parameter_type_validator-ParameterTypeValidator.html[ParameterTypeValidator]` interface

=== Handling parameters
Now you can handle parameter values:

[source,js]
----
var params = routingContext.get("parsedParameters");
var awesomeParameter = params.queryParameter("awesomeParameter");
if ((awesomeParameter !== null && awesomeParameter !== undefined)) {
  if (!awesomeParameter.isEmpty()) {
    // Parameter exists and isn't empty
    // ParameterTypeValidator mapped the parameter in equivalent language object
    var awesome = awesomeParameter.getInteger();
  } else {
    // Parameter exists, but it's empty
  }
} else {
  // Parameter doesn't exist (it's not required)
}

----

As you can see, every parameter is mapped in respective language objects. You can also get a json body:

[source,js]
----
var body = params.body();
if ((body !== null && body !== undefined)) {
  var jsonBody = body.getJsonObject();
}

----