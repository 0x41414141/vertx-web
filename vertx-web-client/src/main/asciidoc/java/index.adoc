= Vert.x Web Client

Vert.x Web Client is an asynchronous HTTP / HTTP/2 client.

The Web Client makes easy to do HTTP request/response interactions with a web server, and provides advanced
features like:

* Json body encoding / decoding
* request/response pumping
* request parameters
* unified error handling

The web client does not deprecate the Vert.x Core `link:../../apidocs/io/vertx/core/http/HttpClient.html[HttpClient]`, it is actually based on
it and therefore inherits its configuration and great features like pooling. The `link:../../apidocs/io/vertx/core/http/HttpClient.html[HttpClient]`
should be used when fine grained control over the HTTP requests/response is necessary.

== Using the web client

To use Vert.x Web Client, add the following dependency to the _dependencies_ section of your build descriptor:

* Maven (in your `pom.xml`):

[source,xml,subs="+attributes"]
----
<dependency>
  <groupId>io.vertx</groupId>
  <artifactId>vertx-web-client</artifactId>
  <version>3.4.0-SNAPSHOT</version>
</dependency>
----

* Gradle (in your `build.gradle` file):

[source,groovy,subs="+attributes"]
----
dependencies {
  compile 'io.vertx:vertx-web-client:3.4.0-SNAPSHOT'
}
----

== Re-cap on Vert.x core HTTP client

Vert.x Web Client uses the API from Vert.x core, so it's well worth getting familiar with the basic concepts of using
`link:../../apidocs/io/vertx/core/http/HttpClient.html[HttpClient]` using Vert.x core, if you're not already.

== Creating a web client

You create an `link:../../apidocs/io/vertx/webclient/WebClient.html[WebClient]` instance with default options as follows

[source,java]
----
WebClient client = WebClient.create(vertx);
----

If you want to configure options for the client, you create it as follows

[source,java]
----
HttpClientOptions options = new HttpClientOptions().setKeepAlive(false);
WebClient client = WebClient.wrap(vertx.createHttpClient(options));
----

== Making requests

=== Simple requests with no body

Often, you’ll want to make HTTP requests with no request body. This is usually the case with HTTP GET, OPTIONS
and HEAD requests

[source,java]
----
WebClient client = WebClient.create(vertx);

// Send a GET request
client
  .get(8080, "myserver.mycompany.com", "/some-uri")
  .send(ar -> {
    if (ar.succeeded()) {
      // Obtain response
      HttpResponse<Buffer> response = ar.result();

      System.out.println("Received response with status code" + response.statusCode());
    } else {
      System.out.println("Something went wrong " + ar.cause().getMessage());
    }
  });

// Send a HEAD request
client
  .head(8080, "myserver.mycompany.com", "/some-uri")
  .send(ar -> {
    if (ar.succeeded()) {
      // Obtain response
      HttpResponse<Buffer> response = ar.result();

      System.out.println("Received response with status code" + response.statusCode());
    } else {
      System.out.println("Something went wrong " + ar.cause().getMessage());
    }
  });
----

You can add query parameters to the request URI in a fluent fashion

[source,java]
----
client
  .get(8080, "myserver.mycompany.com", "/some-uri").addQueryParam("param", "param_value")
  .send(ar -> {});
----

Any request URI parameter will pre-populate the request

[source,java]
----
HttpRequest request = client.get(8080, "myserver.mycompany.com", "/some-uri?param1=param1_value&param2=param2_value");

// Add param3
request.addQueryParam("param3", "param3_value");

// Overwrite param2
request.setQueryParam("param2", "another_param2_value");
----

=== Writing request bodies

When you need to make a request with a body, you use the same API and call then `sendXXX` methods
that expects a body to send.

Use `link:../../apidocs/io/vertx/webclient/HttpRequest.html#sendBuffer-io.vertx.core.buffer.Buffer-io.vertx.core.Handler-[sendBuffer]` to send a body buffer

[source,java]
----
client
  .post(8080, "myserver.mycompany.com", "/some-uri")
  .sendBuffer(buffer, ar -> {
    if (ar.succeeded()) {
      // Ok
    }
  });
----

Sending a single buffer is useful but often you don't want to load fully the content in memory, for this
purpose the web client can send `ReadStream<Buffer>` (for example a `link:../../apidocs/io/vertx/core/file/AsyncFile.html[AsyncFile]`
is a ReadStream<Buffer>`) with the `link:../../apidocs/io/vertx/webclient/HttpRequest.html#sendStream-io.vertx.core.streams.ReadStream-io.vertx.core.Handler-[sendStream]` method

[source,java]
----
client
  .post(8080, "myserver.mycompany.com", "/some-uri")
  .sendStream(stream, resp -> {});
----

The web client takes care of setting up the transfer Pump for you. The request will use chunked transfer
encoding as the length of the stream is not know.

When you know the size of the stream, you shall specify before using the `content-length` header

[source,java]
----
fs.open("content.txt", new OpenOptions(), fileRes -> {
  if (fileRes.succeeded()) {
    ReadStream<Buffer> fileStream = fileRes.result();

    String fileLen = "1024";

    // Send the file to the server using POST
    client
      .post(8080, "myserver.mycompany.com", "/some-uri")
      .putHeader("content-length", fileLen)
      .sendStream(fileStream, ar -> {
        if (ar.succeeded()) {
          // Ok
        }
      });
  }
});
----

==== Json bodies

Often you’ll want to write requests which have a Json body. To send a `link:../../apidocs/io/vertx/core/json/JsonObject.html[JsonObject]`
use the `link:../../apidocs/io/vertx/webclient/HttpRequest.html#sendJsonObject-io.vertx.core.json.JsonObject-io.vertx.core.Handler-[sendJsonObject]`

[source,java]
----
client
  .post(8080, "myserver.mycompany.com", "/some-uri")
  .sendJsonObject(new JsonObject().put("firstName", "Dale").put("lastName", "Cooper"), ar -> {
    if (ar.succeeded()) {
      // Ok
    }
  });
----

In Java, Groovy or Kotlin, you can use the `link:../../apidocs/io/vertx/webclient/HttpRequest.html#sendJson-java.lang.Object-io.vertx.core.Handler-[sendJson]` method that maps
a POJO (Plain Old Java Object) to a Json object using `link:../../apidocs/io/vertx/core/json/Json.html#encode-java.lang.Object-[Json.encode]`
method

[source,java]
----
client
  .post(8080, "myserver.mycompany.com", "/some-uri")
  .sendJson(new User("Dale", "Cooper"), ar -> {
    if (ar.succeeded()) {
      // Ok
    }
  });
----

NOTE: the `link:../../apidocs/io/vertx/core/json/Json.html#encode-java.lang.Object-[Json.encode]` uses the Jackson mapper to encode the object
to Json.

=== Writing request headers

You can write headers to a request using the headers multi-map as follows:

[source,java]
----
HttpRequest request = client.get(8080, "myserver.mycompany.com", "/some-uri");
MultiMap headers = request.headers();
headers.set("content-type", "application/json");
headers.set("other-header", "foo");
----

The headers are an instance of `link:../../apidocs/io/vertx/core/MultiMap.html[MultiMap]` which provides operations for adding,
setting and removing entries. Http headers allow more than one value for a specific key.

You can also write headers using putHeader

[source,java]
----
HttpRequest request = client.get(8080, "myserver.mycompany.com", "/some-uri");
request.putHeader("content-type", "application/json");
request.putHeader("other-header", "foo");
----

=== Reusing requests

The `link:../../apidocs/io/vertx/webclient/HttpRequest.html#send-io.vertx.core.Handler-[send]` method can be called multiple times
safely, making it very easy to configure http requests and reuse them

[source,java]
----
HttpRequest get = client.get(8080, "myserver.mycompany.com", "/some-uri");
get.send(ar -> {
  if (ar.succeeded()) {
    // Ok
  }
});

// Same request again
get.send(ar -> {
  if (ar.succeeded()) {
    // Ok
  }
});
----

== Handling http responses

When the web client sends a request you always deal with a single async result response.

On a success result the callback happens after the response has been fully received.

[source,java]
----
client
  .get(8080, "myserver.mycompany.com", "/some-uri")
  .send(ar -> {
    if (ar.succeeded()) {
      HttpResponse<Buffer> response = ar.result();
      System.out.println("Received response with status code" + response.statusCode());
    } else {
      System.out.println("Something went wrong " + ar.cause().getMessage());
    }
  });
----

=== Decoding responses

By default the web client provides an http response body as a `Buffer` and does not apply
any decoding.

Custom response body decoding can be achieved using `link:../../apidocs/io/vertx/webclient/BodyCodec.html[BodyCodec]`:

* Plain String
* Json object
* Json mapped POJO
* WriteStream

A body codec can decode an arbitrary binary data stream into a specific object instance, saving you the decoding
step in your response handlers.

Use `link:../../apidocs/io/vertx/webclient/BodyCodec.html#jsonObject--[BodyCodec.jsonObject]` To decode a Json object:

[source,java]
----
client
  .get(8080, "localhost", "/something")
  .send(BodyCodec.jsonObject(), ar -> {
    if (ar.succeeded()) {
      HttpResponse<JsonObject> response = ar.result();
      JsonObject body = response.body();
      System.out.println("Received response with status code" + response.statusCode() + " with body " + body);
    } else {
      System.out.println("Something went wrong " + ar.cause().getMessage());
    }
  });
----

Custom Json mapped POJO can be decoded as well:

[source,java]
----
client
  .get(8080, "localhost", "/something")
  .send(BodyCodec.json(User.class), ar -> {
    if (ar.succeeded()) {
      HttpResponse<User> response = ar.result();
      User user = response.body();
      System.out.println("Received response with status code" + response.statusCode() + " with body " +
        user.getFirstName() + " " + user.getLastName());
    } else {
      System.out.println("Something went wrong " + ar.cause().getMessage());
    }
  });
----

You can use the `link:../../apidocs/io/vertx/webclient/BodyCodec.html#stream-io.vertx.core.streams.WriteStream-[BodyCodec.stream]` when large response are
expected. This body codec pumps the response buffers to a `link:../../apidocs/io/vertx/core/streams/WriteStream.html[WriteStream]`
and signals the success or the failure of the operation in the async result response:

[source,java]
----
client
  .get(8080, "localhost", "/something")
  .send(BodyCodec.stream(writeStream), ar -> {
    if (ar.succeeded()) {
      HttpResponse<Void> response = ar.result();
      System.out.println("Received response with status code" + response.statusCode());
    } else {
      System.out.println("Something went wrong " + ar.cause().getMessage());
    }
  });
----

=== RxJava API

The RxJava `link:../../apidocs/io/vertx/rxjava/webclient/HttpRequest.html[HttpRequest]` provides an rx-ified version of the original API,
the `link:../../apidocs/io/vertx/rxjava/webclient/HttpRequest.html#rxSend--[rxSend]` method returns a `Single<HttpResponse<Buffer>>` that
makes the HTTP request upon subscription, as consequence, the `Single` can be subscribed many times.

[source,java]
----
Single<HttpResponse<Buffer>> single = client
  .get(8080, "myserver.mycompany.com", "/some-uri")
  .rxSend();

// Send a request upon subscription of the Single
single.subscribe(response -> {
  System.out.println("Received response with status code" + response.statusCode());
}, error -> {
  System.out.println("Something went wrong " + error.getMessage());
});
----

The obtained `Single` can be composed and chained naturally with the RxJava API

[source,java]
----
Single<String> url = client
  .get(8080, "myserver.mycompany.com", "/some-uri")
  .rxSend()
  .map(HttpResponse::bodyAsString);

// Use the flatMap operator to make a request on the URL Single
url
  .flatMap(u -> client.getAbs(u).rxSend())
  .subscribe(response -> {
    System.out.println("Received response with status code" + response.statusCode());
  }, error -> {
    System.out.println("Something went wrong " + error.getMessage());
  });
----