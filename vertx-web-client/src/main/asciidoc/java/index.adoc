= Vert.x Web Client

Vert.x Web Client is an asynchronous HTTP / HTTP/2 client.

The Web Client makes easy to do HTTP request/response interactions with a web server, and provides advanced
features like:

* Json body encoding / decoding
* request/response pumping
* error handling

The web client does not deprecate the Vert.x Core `link:../../apidocs/io/vertx/core/http/HttpClient.html[HttpClient]`, it is actually based on
it and therefore inherits its configuration and great features like pooling. The `link:../../apidocs/io/vertx/core/http/HttpClient.html[HttpClient]`
should be used when fine grained control over the HTTP requests/response is necessary.

== Using the web client

To use Vert.x Web Client, add the following dependency to the _dependencies_ section of your build descriptor:

* Maven (in your `pom.xml`):

[source,xml,subs="+attributes"]
----
<dependency>
  <groupId>io.vertx</groupId>
  <artifactId>vertx-web-client</artifactId>
  <version>3.4.0-SNAPSHOT</version>
</dependency>
----

* Gradle (in your `build.gradle` file):

[source,groovy,subs="+attributes"]
----
dependencies {
  compile 'io.vertx:vertx-web-client:3.4.0-SNAPSHOT'
}
----

== Re-cap on Vert.x core HTTP client

Vert.x Web Client uses the API from Vert.x core, so it's well worth getting familiar with the basic concepts of using
`link:../../apidocs/io/vertx/core/http/HttpClient.html[HttpClient]` using Vert.x core, if you're not already.

== Creating a web client

You create an `link:../../apidocs/io/vertx/webclient/WebClient.html[WebClient]` instance with default options as follows:

[source,java]
----
WebClient client = WebClient.create(vertx);
----

If you want to configure options for the client, you create it as follows:

[source,java]
----
HttpClientOptions options = new HttpClientOptions().setKeepAlive(false);
WebClient client = WebClient.wrap(vertx.createHttpClient(options));
----

== Making requests

=== Simple requests with no request body

Often, youâ€™ll want to make HTTP requests with no request body. This is usually the case with HTTP GET, OPTIONS
and HEAD requests:

[source,java]
----
WebClient client = WebClient.create(vertx);

// Send a GET request
client
  .get(8080, "myserver.mycompany.com", "/some-uri")
  .send(ar -> {
    if (ar.succeeded()) {
      // Obtain response
      HttpResponse<Buffer> response = ar.result();

      System.out.println("Received response with status code" + response.statusCode());
    } else {
      System.out.println("Something went wrong " + ar.cause().getMessage());
    }
  });

// Send a HEAD request
client
  .head(8080, "myserver.mycompany.com", "/some-uri")
  .send(ar -> {
    if (ar.succeeded()) {
      // Obtain response
      HttpResponse<Buffer> response = ar.result();

      System.out.println("Received response with status code" + response.statusCode());
    } else {
      System.out.println("Something went wrong " + ar.cause().getMessage());
    }
  });
----

You can add query parameters to the request URI in a fluent fashion:

[source,java]
----
client
  .get(8080, "myserver.mycompany.com", "/some-uri").addQueryParam("param", "param_value")
  .send(ar -> {});
----

Any request URI parameter will pre-populate the request:

[source,java]
----
HttpRequest request = client.get(8080, "myserver.mycompany.com", "/some-uri?param1=param1_value&param2=param2_value");

// Add param3
request.addQueryParam("param3", "param3_value");

// Overwrite param2
request.setQueryParam("param2", "another_param2_value");
----

=== Requests with a body

todo : show how to send a buffer or stream buffers

==== Sending json

==== Sending forms

=== Reusing requests

The `link:../../apidocs/io/vertx/webclient/HttpRequest.html#send-io.vertx.core.Handler-[send]` method can be called multiple times
safely, making it very easy to configure http requests and reuse them:

[source,java]
----
HttpRequest get = client.get(8080, "myserver.mycompany.com", "/some-uri");
get.send(ar -> {});

// Same request again
get.send(ar -> {});
----

=== Decoding responses

todo

=== RxJava API

The RxJava `link:../../apidocs/io/vertx/rxjava/webclient/HttpRequest.html[HttpRequest]` provides an rx-ified version of the original API,
the `link:../../apidocs/io/vertx/rxjava/webclient/HttpRequest.html#rxSend--[rxSend]` method returns a `Single<HttpResponse<Buffer>>` that
makes the HTTP request upon subscription, as consequence, the `Single` can be subscribed many times.

[source,java]
----
Single<HttpResponse<Buffer>> single = client
  .get(8080, "myserver.mycompany.com", "/some-uri")
  .rxSend();

// Send a request upon subscription of the Single
single.subscribe(response -> {
  System.out.println("Received response with status code" + response.statusCode());
}, error -> {
  System.out.println("Something went wrong " + error.getMessage());
});
----

The obtained `Single` can be composed and chained naturally with the RxJava API:

[source,java]
----
Single<String> url = client
  .get(8080, "myserver.mycompany.com", "/some-uri")
  .rxSend()
  .map(HttpResponse::bodyAsString);

// Use the flatMap operator to make a request on the URL Single
url
  .flatMap(u -> client.getAbs(u).rxSend())
  .subscribe(response -> {
    System.out.println("Received response with status code" + response.statusCode());
  }, error -> {
    System.out.println("Something went wrong " + error.getMessage());
  });
----